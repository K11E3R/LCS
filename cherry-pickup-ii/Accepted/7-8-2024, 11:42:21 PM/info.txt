{"id":1314458684,"question_id":1559,"lang":"rust","lang_name":"Rust","time":"2 weeks, 3 days","timestamp":1720474941,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1314458684/","is_pending":"Not Pending","title":"Cherry Pickup II","memory":"2.3 MB","code":"impl Solution {\n    pub fn cherry_pickup(grid: Vec<Vec<i32>>) -> i32 {\n        let (m, n) = (grid.len(), grid[0].len());\n        let mut dp = vec![vec![i32::MIN; n]; n];\n        dp[0][n - 1] = grid[0][0] + grid[0][n - 1];\n        \n        for i in 1..m {\n            let mut new_dp = vec![vec![i32::MIN; n]; n];\n            for j1 in 0..n {\n                for j2 in 0..n {\n                    let val = grid[i][j1] + if j1 == j2 { 0 } else { grid[i][j2] };\n                    for y1 in (j1.saturating_sub(1))..=(j1 + 1).min(n - 1) {\n                        for y2 in (j2.saturating_sub(1))..=(j2 + 1).min(n - 1) {\n                            if dp[y1][y2] != i32::MIN {\n                                new_dp[j1][j2] = new_dp[j1][j2].max(dp[y1][y2] + val);\n                            }\n                        }\n                    }\n                }\n            }\n            dp = new_dp;\n        }\n        \n        dp.into_iter().flatten().max().unwrap_or(0)\n    }\n}\n","compare_result":"11111111111111111111111111111111111111111111111111111111111","title_slug":"cherry-pickup-ii","has_notes":false,"flag_type":1}