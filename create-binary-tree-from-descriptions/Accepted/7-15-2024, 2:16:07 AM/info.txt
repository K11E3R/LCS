{"id":1321261267,"question_id":2306,"lang":"rust","lang_name":"Rust","time":"1 week, 4 days","timestamp":1721002567,"status":10,"status_display":"Accepted","runtime":"89 ms","url":"/submissions/detail/1321261267/","is_pending":"Not Pending","title":"Create Binary Tree From Descriptions","memory":"4.6 MB","code":"// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::rc::Rc;\nimpl Solution {\n    fn dfs(val: i32, map: &HashMap<i32, [i32; 2]>) -> Option<Rc<RefCell<TreeNode>>> {\n        if val == 0 {\n            return None;\n        }\n        let mut left = None;\n        let mut right = None;\n        if let Some(&[l_val, r_val]) = map.get(&val) {\n            left = Self::dfs(l_val, map);\n            right = Self::dfs(r_val, map);\n        }\n        Some(Rc::new(RefCell::new(TreeNode { val, left, right })))\n    }\n\n    pub fn create_binary_tree(descriptions: Vec<Vec<i32>>) -> Option<Rc<RefCell<TreeNode>>> {\n        let mut map = HashMap::new();\n        let mut is_root = HashMap::new();\n        for description in descriptions.iter() {\n            let (parent, child, is_left) = (description[0], description[1], description[2] == 1);\n            let [mut left, mut right] = map.get(&parent).unwrap_or(&[0, 0]);\n            if is_left {\n                left = child;\n            } else {\n                right = child;\n            }\n            if !is_root.contains_key(&parent) {\n                is_root.insert(parent, true);\n            }\n            is_root.insert(child, false);\n            map.insert(parent, [left, right]);\n        }\n        for key in is_root.keys() {\n            if *is_root.get(key).unwrap() {\n                return Self::dfs(*key, &map);\n            }\n        }\n        None\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"create-binary-tree-from-descriptions","has_notes":false,"flag_type":1}