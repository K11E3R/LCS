{"id":1332347390,"question_id":236,"lang":"rust","lang_name":"Rust","time":"1 day, 23 hours","timestamp":1721858499,"status":10,"status_display":"Accepted","runtime":"11 ms","url":"/submissions/detail/1332347390/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Tree","memory":"3.8 MB","code":"// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Tree,\n//   pub right: Tree,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\ntype Tree = Option<Rc<RefCell<TreeNode>>>;\n\n#[repr(u8)]\n#[derive(Copy, Clone, PartialEq, Eq)]\nenum Direction {Left, Right}\n\nuse Direction::*;\n\nfn get_node(tree: Tree, path: Vec<Direction>) -> Tree {\n    let mut curr_node = tree;\n\n    if !path.is_empty() {\n        for dir in path {\n            match dir {\n                Left => curr_node = curr_node.map(|n| n.borrow().left.clone()).flatten(),\n            \n                Right => curr_node = curr_node.map(|n| n.borrow().right.clone()).flatten(),\n            }\n        }\n    }\n\n    curr_node\n}\n\nfn get_path_to_node(root: Tree, target: Tree) -> Vec<Direction> {\n    let target_node = target.unwrap();\n    let root_node = root.unwrap();\n\n    let mut node_stack: Vec<(Rc<RefCell<TreeNode>>, Vec<Direction>)> = vec![(root_node.clone(), vec![])];\n\n    while let Some((node, path)) = node_stack.pop() {\n        if node == target_node {\n            return path;\n        }\n\n        if let Some(ln) = node.borrow().left.as_ref() {\n            let mut left_path = path.clone();\n            left_path.push(Left);\n            node_stack.push((ln.clone(), left_path));\n        }\n\n        if let Some(rn) = node.borrow().right.as_ref() {\n            let mut right_path = path.clone();\n            right_path.push(Right);\n            node_stack.push((rn.clone(), right_path));\n        }\n    }\n\n    vec![]\n}\n\n\nimpl Solution {\n    pub fn lowest_common_ancestor(root: Tree, p: Tree, q: Tree) -> Tree {\n        let p_path = get_path_to_node(root.clone(), p.clone());\n        let q_path = get_path_to_node(root.clone(), q.clone());\n\n        let lca_path = p_path.into_iter()\n            .zip(q_path.into_iter())\n            .take_while(|(p_dir, q_dir)| p_dir == q_dir)\n            .map(|tup_dir| tup_dir.0)\n            .collect::<Vec<Direction>>();\n\n        get_node(root.clone(), lca_path)\n    }\n}","compare_result":"11111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-tree","has_notes":false,"flag_type":1}