{"id":1332346516,"question_id":904,"lang":"rust","lang_name":"Rust","time":"1 day, 23 hours","timestamp":1721858387,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/1332346516/","is_pending":"Not Pending","title":"Leaf-Similar Trees","memory":"2.2 MB","code":"// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//     pub val: i32,\n//     pub left: Option<Rc<RefCell<TreeNode>>>,\n//     pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nimpl Solution {\n    fn is_leaf(node: &TreeNode) -> bool {\n        node.left.is_none() && node.right.is_none()\n    }\n\n    fn leaves(tree: &Option<Rc<RefCell<TreeNode>>>) -> Box<dyn Iterator<Item = i32>> {\n        if let Some(root) = tree {\n            let root = root.borrow();\n            if Self::is_leaf(&root) {\n                Box::new(std::iter::once(root.val))\n            } else {\n                Box::new(Self::leaves(&root.left).chain(Self::leaves(&root.right)))\n            }\n        } else {\n            Box::new(std::iter::empty())\n        }\n    }\n\n    pub fn leaf_similar(\n        root1: Option<Rc<RefCell<TreeNode>>>,\n        root2: Option<Rc<RefCell<TreeNode>>>,\n    ) -> bool {\n        let l1 = Self::leaves(&root1);\n        let l2 = Self::leaves(&root2);\n\n        l1.eq(l2)\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111","title_slug":"leaf-similar-trees","has_notes":false,"flag_type":1}