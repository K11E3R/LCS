{"id":1332346292,"question_id":904,"lang":"rust","lang_name":"Rust","time":"1 day, 23 hours","timestamp":1721858358,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1332346292/","is_pending":"Not Pending","title":"Leaf-Similar Trees","memory":"N/A","code":"// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn leaf_similar(root1: Option<Box<TreeNode>>, root2: Option<Box<TreeNode>>) -> bool {\n        let mut list1 = Vec::new();\n        let mut list2 = Vec::new();\n        recursion(&root1, &mut list1);\n        recursion(&root2, &mut list2);\n        list1 == list2\n    }\n\n    fn recursion(node: &Option<Box<TreeNode>>, leaf_list: &mut Vec<i32>) {\n        if let Some(node) = node {\n            if node.left.is_none() && node.right.is_none() {\n                leaf_list.push(node.val);\n            }\n            recursion(&node.left, leaf_list);\n            recursion(&node.right, leaf_list);\n        }\n    }\n}","compare_result":null,"title_slug":"leaf-similar-trees","has_notes":false,"flag_type":1}